package com.ericsson.bss

import com.ericsson.bss.decorators.BuildEnvironmentDecorator
import com.ericsson.bss.decorators.BuildStepsDecorator
import com.ericsson.bss.decorators.BuildTriggersDecorator
import com.ericsson.bss.decorators.PostBuildStepsDecorator
import com.ericsson.bss.decorators.ProjectDecorator
import com.ericsson.bss.decorators.SCMDecorator
import com.ericsson.bss.util.Email
import com.ericsson.bss.util.GitUtil
import com.ericsson.bss.util.RepositoryMavenConfig
import com.ericsson.bss.util.RepositoryJavaConfig

import javaposse.jobdsl.dsl.DslFactory
import javaposse.jobdsl.dsl.Job
import hudson.FilePath

public abstract class AbstractJobBuilder {

    protected String injectPortAllocation = 'scripts/InjectPortAllocation.groovy'

    public static final DSL_DESCRIPTION = "<p><i>This job is generated by " +
    "<a href='https://gerrit.epk.ericsson.se/plugins/gitiles/tools/eta/jenkins-dsl/+/refs/heads/master/README.md'>DSL</a></i></p>"
    public static final DETAILED_JOB_CONFIGURATION_DESCRIPTION = "<p>What does this job do in detail? Click the \"View Configuration\"" +
    " in the menu to the left to see how it is configured.</p>"
    public static final BSSF_MAVEN_CI_DESCRIPTION = "<p>Please see <a href=\"https://links.lmera.ericsson.se/bssf-maven-ci-environment\">" +
    "BSSF CI Environment sequence-diagram</a> for the build environment flow.</p>"
    public static final BSSF_LINK_TO_MAVEN_TROUBLESHOOT = 'https://eta.epk.ericsson.se/wiki/index.php5/Maven_troubleshoot'
    public static final RESTRICT_LABEL_MESOS = 'Linux_redhat_6.2_x86_64_mesos'
    // RESTRICT_LABEL_MESOS_LIGHT is only for keepalive jobs and jobs that hardly uses any resources.
    public static final RESTRICT_LABEL_MESOS_LIGHT = 'Linux_redhat_6.2_x86_64_mesos_light'
    public static final CUSTOM_WORKSPACE_MESOS = "workspace/\${JOB_NAME}"

    public static final GRAPHVIZ_HOME = "/opt/local/dev_tools/graphviz/2.28.0/bin"

    protected static final GROOVY_INSTALLATION_NAME = 'Groovy 2.4.4'
    public static final MAVEN_VERSION = '3.3.9'
    public static final MAVEN_SETTINGS_PATH = '/proj/eta-automation/maven/varnish/'
    public static final NO_VARNISH_MAVEN_SETTINGS_PATH = '/proj/eta-automation/maven/'
    public static final PATH_TO_JOB_CONFIG = "/proj/eta-automation/jenkins/kascmadm/job_config/"
    public static final MVN_SETTINGS = '--settings \${MAVEN_SETTINGS} -Dorg.ops4j.pax.url.mvn.settings=\${MAVEN_SETTINGS}'
    public static final MVN_REPOSIOTRY = '-Dmaven.repo.local=\${MAVEN_REPOSITORY} ' +
    '-Dorg.ops4j.pax.url.mvn.localRepository=\${MAVEN_REPOSITORY}'
    public static final MVN_RELEASE_PARAMETERS = MVN_SETTINGS + ' ' + MVN_REPOSIOTRY + ' -Darguments="' + MVN_SETTINGS + ' ' + MVN_REPOSIOTRY + '"'
    protected static final MVN_UPDATE = '-U'
    protected static
    final MAVEN_PARAMETERS = MVN_BATCH_MODE + " -Dsurefire.useFile=false " +
    MVN_SETTINGS + " " + MVN_REPOSIOTRY + " -Djava.io.tmpdir=\${WS_TMP}"
    protected static final JACOCO_AGENT = 'org.jacoco:jacoco-maven-plugin:0.7.4.201502262128:prepare-agent'

    public static final JDK_VERSION = 'Latest JDK 1.7 64bit'

    public static final SONAR_JDK_VERSION = 'Latest JDK 1.8 64bit'

    protected static final String SCM_POLLING = 'H/30 * * * *'
    protected static final String SCM_POLLING_FREQUENT = 'H/10 * * * *'

    protected static final JOB_PRIORITY_GERRIT_JOBS = 1
    protected static final JOB_PRIORITY = 2

    protected static final DAYS_KEEP = 10
    protected static final BUILDS_KEEP = 100
    private static final DAYS_ARTIFACT_KEEP = 10
    private static final ARTIFACT_KEEP = 100

    private static final MVN_BATCH_MODE = '-B -e'
    protected static final MVN_SIGN_SKIP = '-Djarsigner.skip=true'
    public static final JAVA_TOOL_OPTIONS = "-Xss1M -Xms256M -Xmx3G -XX:MaxPermSize=512m -XX:SelfDestructTimer=\${JOB_TIMEOUT} -Djava.io.tmpdir=\${WS_TMP}"
    public static final MAVEN_OPTS = "-server " + JAVA_TOOL_OPTIONS
    protected static final MVN_OSGI_PORT = '-DOSGI_PORT_OVERRIDE=\${ALLOCATED_PORT}'
    protected static final POM_XML = "/pom.xml"

    public static final int DEFAULT_JOB_TIMEOUT = 15
    protected int timeoutForJob = DEFAULT_JOB_TIMEOUT

    protected int timeoutForClone = 15

    protected String profilesToBeUsed
    protected Map extraEnvironmentVariables
    protected boolean verboseGerritFeedback = true

    protected String gerritUser = null
    protected String gerritServer = null

    protected String jenkinsCodeQualityUser = null
    protected String jenkinsUnitTestUser = null
    protected String jenkinsIntegrationTestUser = null
    protected String jenkinsJiveTestUser = null

    protected String mavenRepositoryPath
    protected String mavenSettingsFile = null

    protected Job job
    protected String jobName
    protected String gerritName
    protected boolean generateGUIconfig = false
    protected boolean symlinkWorkspace = false
    protected boolean runParallelThreads = true
    protected String mavenReleaseUser = null
    protected String workspacePath
    protected DslFactory dslFactory
    protected boolean runXvfb = true

    protected String gitEmail = null
    protected String gitName = null

    protected String gitReference = "/workarea/bss-f_gen/kascmadm/.gitclonecache"

    protected String gitIncludedRegions = ""
    protected String gitExcludedRegions = ""
    protected String mavenProjectLocation = ""

    protected PrintStream out

    protected String projectName
    protected String extraMavenParameters

    protected boolean enabled = true
    protected  String targetMachine = RESTRICT_LABEL_MESOS

    public void initProject(Job job) {
        this.job = job

        if (mavenProjectLocation) {
            mavenProjectLocation = mavenProjectLocation + POM_XML
        }

        this.jenkinsJiveTestUser = "jenkins-jive-test"

        if (gerritServer.equalsIgnoreCase(Project.GERRIT_EPK_SERVER)) {
            this.jenkinsCodeQualityUser = "jenkins-code-quality"
            this.jenkinsUnitTestUser = "jenkins-unit-test"
            this.jenkinsIntegrationTestUser = "jenkins-integration-test"
            this.gitEmail = gerritUser + "@noreply.epk.ericsson.se"
        } else if (gerritServer.equalsIgnoreCase(Project.GERRIT_FORGE_SERVER)) {
            this.jenkinsCodeQualityUser = 'bssf_code_quality_local'
            this.jenkinsUnitTestUser = 'bssf_unit_test_local'
            this.jenkinsIntegrationTestUser = 'bssf_integration_test_local'
            this.gitEmail = gerritUser + "@mailman.lmera.ericsson.se"
            this.mavenReleaseUser = gerritUser
        }
        this.gitName = 'Automated User ' + gerritUser

        if (job.getName().contains("gui")) {
            this.generateGUIconfig = true
        }

        if (generateGUIconfig) {
            runParallelThreads = false
        }

        job.with {
            logRotator(DAYS_KEEP, BUILDS_KEEP, DAYS_ARTIFACT_KEEP, ARTIFACT_KEEP)
            jdk(getJavaVersion())
            properties {
                priority(JOB_PRIORITY)
                environmentVariables { groovy(this.getScriptToSetDynamicTimeout()) }
            }

            wrappers {
                timestamps()
                if (runXvfb) {
                    configureBuildEnvironment().runXvfbDuringBuild()
                }
            }
        }
        setRestrictLabel()
        archiveArtifacts()
        if (this.enabled) {
            this.enable()
        }
        else {
            this.disable()
        }
    }

    protected void init(String jobName) {
        this.jobName = jobName
        this.job = dslFactory.freeStyleJob(jobName)
        out.println("Creating " + jobName)
    }

    protected void addGitRepository(String gerritName, String branchName) {
        job.with {

            String gitURL = GitUtil.getGitUrl(gerritServer, gerritName)

            scm {
                git {
                    remote { url(gitURL) }
                    branch('origin/' + branchName)
                    if (!GitUtil.containsWildcards(branchName)) {
                        extensions {
                            localBranch(branchName)
                        }
                    }
                }
            }

            configure { project ->
                if (!GitUtil.isLocatedInGitolite(gerritName)) {
                    project / scm / extensions << 'hudson.plugins.git.extensions.impl.UserIdentity' {
                        name(gitName)
                        email(gitEmail)
                    }
                }
                project / scm / extensions << 'hudson.plugins.git.extensions.impl.CloneOption' {
                    shallow(false)
                    reference(gitReference)
                    timeout(timeoutForClone)
                }
                if (gitIncludedRegions || gitExcludedRegions) {
                    project / scm / extensions << 'hudson.plugins.git.extensions.impl.PathRestriction' {
                        includedRegions(gitIncludedRegions)
                        excludedRegions(gitExcludedRegions)
                    }
                }
                if (!GitUtil.isLocatedInGitolite(gerritName)) {
                    if (gerritServer.equalsIgnoreCase(Project.GERRIT_FORGE_SERVER)) {
                        project / scm / browser(class: 'hudson.plugins.git.browser.GitWeb') {
                            url 'https://gerritforge.lmera.ericsson.se/gerrit/gitweb?p=' + gerritName + '.git'
                        }
                    }
                    else if (gerritServer.equalsIgnoreCase(Project.GERRIT_CENTRAL_SERVER)) {
                        project / scm / browser(class: 'hudson.plugins.git.browser.GitWeb') {
                            url 'https://gerrit.ericsson.se/gitweb?p=' + gerritName + '.git'
                        }
                    }
                    else {
                        project / scm / browser(class: 'hudson.plugins.git.browser.Gitiles') {
                            url 'https://gerrit.epk.ericsson.se/plugins/gitiles/' + gerritName
                        }
                    }
                }
            }
        }
    }

    protected void addGitRepository(String gerritName) {
        addGitRepository(gerritName, 'master')
    }

    /**
     * Should only be used if HOME has been overriden in the job.
     *
     * @param repositoryLocation
     * @return
     */
    protected String cleanUpWorkspace(String repositoryLocation) {
        return getShellCommentDescription("Clean up workspace") +
                "cd " + repositoryLocation + "\n" +
                "git clean -fdxq -e \$(basename \${MAVEN_REPOSITORY})/\n" +
                createHomeTmpFolder()
    }

    protected String cleanUpWorkspaceMesos(String repositoryLocation) {
        return getShellCommentDescription("Clean up workspace") +
                "cd " + repositoryLocation + "\n" +
                "git clean -fdxq\n" +
                createHomeTmpFolder()
    }

    protected String createHomeTmpFolder() {
        String createHomeTmpCommand = "mkdir -p \${WORKSPACE}/.tmp/home/"

        if (generateGUIconfig) {
            createHomeTmpCommand += "\n" + linkCdtCache()
        }

        return createHomeTmpCommand
    }

    protected String linkCdtCache() {
        return  "mkdir -p \${WORKSPACE}/.tmp/home/.cdt/\n" +
                "ln -sf /proj/eta-automation/jenkins/kascmadm/.cdt/cache \${WORKSPACE}/.tmp/home/.cdt/cache"
    }

    public static String getShellCommentDescription(String text) {
        text = "# " + text + " #\n"
        String comment = ""
        for (int i = 0; i < text.length() - 1; i++) {
            comment += "#"
        }
        comment += "\n"

        return comment + text + comment
    }

    protected String removeOldArtifacts() {
        return getShellCommentDescription("Remove old artifacts") +
                "mkdir -p \${MAVEN_REPOSITORY}\n" +
                "rm -rf \${MAVEN_REPOSITORY}/com/ericsson\n" +
                "find \${MAVEN_REPOSITORY} -type f -amin +7200 -mmin +7200 -delete -o -type f -name '*-SNAPSHOT*' -delete -o " +
                "-type d -empty -delete -o -type f -name '*lastUpdated' -delete"
    }

    protected String gitConfig(String repositoryLocation) {
        String gitConfigEmail = ""
        String gitConfigName = ""

        if (gitEmail != null) {
            gitConfigEmail = "git config --replace-all user.email " + gitEmail + "\n"
            gitConfigName = "git config --replace-all user.name '" + gitName + "'\n"
        }

        return getShellCommentDescription("Git Config") +
                "cd " + repositoryLocation + "\n" +
                "git config --replace-all gc.reflogexpireunreachable '2 days ago'\n" +
                "git config --replace-all gc.reflogexpire '2 days ago'\n" +
                "git config --replace-all gc.pruneexpire '2 days ago'\n" +
                gitConfigEmail +
                gitConfigName
    }

    protected String getGitCache(String repositoryLocation) {
        return getShellCommentDescription("Git cache") +
                "cd " + repositoryLocation + "\n" +
                "printf \"\${GIT_CLONE_CACHE}/.git/objects\" > .git/objects/info/alternates\n" +
                "git gc --auto"
    }

    protected String gconfWorkspaceWorkaround() {
        return dslFactory.readFileFromWorkspace('scripts/gconf_workaround.sh')
    }

    protected static String getMavenGeneralBuildParameters() {
        return MVN_BATCH_MODE + " \\\n" +
                MVN_SIGN_SKIP + " \\\n" +
                MVN_SETTINGS + " \\\n" +
                MVN_REPOSIOTRY + " \\\n" +
                MVN_OSGI_PORT
    }

    protected String injectPortAllocationScript() {
        if (injectPortAllocation.equals("")) {
            return ""
        }
        else {
            return dslFactory.readFileFromWorkspace(injectPortAllocation)
        }
    }

    protected String getScriptToSetDynamicTimeout() {
        String dynamicTimeoutScript = dslFactory.readFileFromWorkspace("scripts/setDynamicTimeoutIfRelease.groovy")

        return  dynamicTimeoutScript.replace("%DEFAULT_TIMEOUT%", timeoutForJob.toString())
    }

    protected void injectEnv(Map environmentVariable) {
        job.with {
            wrappers {
                environmentVariables {
                    envs(environmentVariable)
                    groovy(injectPortAllocationScript())
                }
            }
        }
    }

    protected getInjectVariables() {
        Map env = [:]

        if (symlinkWorkspace) {
            env.put("WORKSPACE_ORIG", "\${WORKSPACE}")
            env.put("WORKSPACE", getWorkspaceLocation())
            env.put("WS_TMP", getWorkspaceLocation() + "/.tmp/")
        } else {
            env.put("WS_TMP", "\${WORKSPACE}/.tmp/")
        }
        env.put("HOME", "\${WS_TMP}home/")
        env.put("GIT_HOME", "/opt/local/dev_tools/git/latest")
        env.put("MAVEN_REPOSITORY", mavenRepositoryPath)
        env.put("GIT_CLONE_CACHE", GitUtil.getCloneReference())
        env.put("MAVEN_SETTINGS", mavenSettingsFile)
        env.put("JAVA_TOOL_OPTIONS", JAVA_TOOL_OPTIONS)
        env.put("M2_HOME", getMavenHome())
        env.put("M2", "\${M2_HOME}/bin")
        env.put("MAVEN_OPTS", MAVEN_OPTS)
        env.put("SONAR_USER_HOME", "\${WORKSPACE}/.sonar")
        env.put('PYTHONPATH', '/opt/local/dev_tools/python/latest/')

        if (generateGUIconfig) {
            env.put("CDT_INSTALL_FOLDER", getWorkspaceLocation())
            env.put("FIREFOXDIR", "/proj/eta-tools/firefox/45.0esr/Linux_i386_64/firefox")
            env.put("FFMPEGDIR", "/proj/eta-tools/ffmpeg/3.0/Linux_x86_64/bin")
            env.put("npm_config_cache", "\${WS_TMP}/npm_config_cache")
            env.put("npm_config_prefix", "\${CDT_INSTALL_FOLDER}/node_modules")
            env.put("PATH", "/proj/eta-tools/cdt/latest/node_modules/bin/:\${PYTHONPATH}/bin:\${GIT_HOME}/bin:\${M2}:\${FFMPEGDIR}:\${FIREFOXDIR}" +
                    ":\${npm_config_prefix}/bin/:/opt/local/dev_tools/nodejs/node-v0.10.20-linux-x64/bin/:\${PATH}")
        } else {
            env.put("PATH", "\${PYTHONPATH}/bin:\${GIT_HOME}/bin:\${M2}:\${PATH}")
        }

        if (extraEnvironmentVariables != null) {
            env.putAll(extraEnvironmentVariables)
        }

        return env
    }

    protected String getWorkspaceLocation() {
        //TODO: should be dynamic specified
        if (isExternalJenkins()) {
            return "/tmp/jenkins-eforge-ln/\${JOB_NAME}/\${MESOS_EXECUTOR_NUMBER}"
        } else {
            return "/tmp/jenkins-ka-ln/\${JOB_NAME}/\${MESOS_EXECUTOR_NUMBER}"
        }
    }

    protected void addTimeoutConfig() {

        job.with {
            configure{ project ->
                //API only supports int and not String's.
                //https://issues.jenkins-ci.org/browse/JENKINS-35228
                project / buildWrappers / 'hudson.plugins.build__timeout.BuildTimeoutWrapper' / strategy(class: "hudson.plugins.build_timeout.impl.AbsoluteTimeOutStrategy") { timeoutMinutes "\${JOB_TIMEOUT}" }
                project / buildWrappers / 'hudson.plugins.build__timeout.BuildTimeoutWrapper' / operationList / 'hudson.plugins.build__timeout.operations.AbortOperation'
                project / buildWrappers / 'hudson.plugins.build__timeout.BuildTimeoutWrapper' / operationList / 'hudson.plugins.build__timeout.operations.WriteDescriptionOperation' { description "Build failed due to timeout after {0} minutes" }
            }
        }
    }

    protected void setParameterPool(String projectNames = jobName, String parameterName = '', String poolValue = '') {
        /*
        Parameter-Pool-plugin allows use of a unique parameter value per concurrent build.
        Rules:
            The plugin reads from left to right for parameter values.
            The first value that is not in a running build is picked.
            If prefere failed builds is selected, the first value that is from a failed build and not in a running build is picked.
        More info: https://wiki.jenkins-ci.org/display/JENKINS/Parameter+Pool+Plugin
         */
        job.with {
            configure{ project ->
                project / builders / 'org.jenkinsci.plugins.parameterpool.ParameterPoolBuilder' {
                    // Projects that should be checked for running parameter pool values.
                    projects(projectNames)
                    // Name for the parameter. This name will be exposed as an environmental variable.
                    // This allows subsequent build steps to use the value.
                    name(parameterName)
                    // Values for the parameter pool, separate values by comma.
                    // For ranges of values use [start..end], E.g. for say vm1, vm2, vm3, vm4 do vm[1..4].
                    values(poolValue)
                }
            }
        }
    }

    protected String createVirtualEnvDir() {
        return getShellCommentDescription("Workaround to handle too long workspace path in virtualenv") +
                "rm -rf \$VENV_TMP\n" +
                "mkdir -p \$VENV_TMP"
    }

    protected String cleanVirtualEnvDir() {
        return getShellCommentDescription("Clean virtual env directory") +
                "rm -rf \$VENV_TMP\n"
    }

    protected String getCDTSonarTesReportWorkaround() {
        return getShellCommentDescription("Workaround to get sonar to pick up unit test report") +
                'find . -type f -name \'junit.xml\' -exec csh -c \'set file={};set dir=`dirname $file`; cp $dir/junit.xml $dir/TEST-all.xml\' \\;'
    }

    protected boolean isExternalJenkins() {
        return gerritServer.equalsIgnoreCase(Project.GERRIT_FORGE_SERVER)
    }

    protected boolean isInternalJenkins() {
        return gerritServer.equalsIgnoreCase(Project.GERRIT_EPK_SERVER)
    }

    protected String symlinkMesosWorkSpace() {
        return getShellCommentDescription("Symlink mesos long workspace path") +
                "mkdir -p \$(dirname \"" + getWorkspaceLocation() + "\")\n" +
                "rm -rf " + getWorkspaceLocation() + "\n" +
                "ln -s \${WORKSPACE_ORIG} " + getWorkspaceLocation() + "\n" +
                "ls -dl " + getWorkspaceLocation()
    }

    protected String setCilServerVirtualenvDir() {
        return getShellCommentDescription("Workaround of virtualenv for long workspace path") +
                "cd \${WORKSPACE}\n" +
                "sed -i 's/ve_dir=\${here}/ve_dir=\${WORKSPACE}\\/cil-deploy/' \${WORKSPACE}/cil-deploy/basictest.sh"
    }

    protected void setRestrictLabel(String restrictLabel = targetMachine) {
        if ("" == targetMachine) {
            restrictLabel = RESTRICT_LABEL_MESOS
        }

        job.with { label(restrictLabel) }
    }

    protected void addExtendableEmail(String mailRecipientList = '\$DEFAULT_RECIPIENTS') {
        Closure emailTrigger = {
            email {
                recipientList '$PROJECT_DEFAULT_RECIPIENTS'
                subject '$PROJECT_DEFAULT_SUBJECT'
                body '$PROJECT_DEFAULT_CONTENT'
                recipientProviders {
                    'hudson.plugins.emailext.plugins.recipients.ListRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.CulpritsRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.DevelopersRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.RequesterRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.FailingTestSuspectsRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.UpstreamComitterRecipientProvider' { }
                }
                'attachmentsPattern' { }
                'attachBuildLog' 'false'
                'compressBuildLog' 'false'
                'replyTo' '$PROJECT_DEFAULT_REPLYTO'
                'contentType' 'project'
            }
        }

        job.with {
            configure { project ->
                project / publishers << 'hudson.plugins.emailext.ExtendedEmailPublisher' {
                    recipientList mailRecipientList
                    configuredTriggers {
                        'hudson.plugins.emailext.plugins.trigger.FailureTrigger' emailTrigger
                        'hudson.plugins.emailext.plugins.trigger.UnstableTrigger' emailTrigger
                        'hudson.plugins.emailext.plugins.trigger.AbortedTrigger' emailTrigger
                    }
                    contentType 'text/html'
                    defaultSubject '$DEFAULT_SUBJECT'
                    defaultContent '${SCRIPT, template="email_with_upstream_changes.template"}'
                    'attachmentsPattern' { }
                    'presendScript' '$DEFAULT_PRESEND_SCRIPT'
                    'attachBuildLog' 'false'
                    'compressBuildLog' 'false'
                    'replyTo' '$DEFAULT_REPLYTO'
                    'saveOutput' 'false'
                    'disabled' 'false'
                }
            }
        }
    }

    protected void addTimeoutAndAbortConfig(int timeoutMinutes) {
        job.with {
            wrappers {
                timeout {
                    absolute(timeoutMinutes)
                    abortBuild()
                    writeDescription('Build aborted due to timeout after {0} minutes')
                }
            }
        }
    }

    protected void addEmailNotificationConfig(Email email) {
        job.with {
            configure { project ->
                project / publishers << 'hudson.plugins.emailext.ExtendedEmailPublisher' {
                    recipientList email.getRecipient()
                    configuredTriggers {
                        if (email.getFailureTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.FailureTrigger' emailTrigger(email.getFailureTriggerSubject())
                        }

                        if (email.getFixedTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.FixedTrigger' emailTrigger(email.getFixedTriggerSubject())
                        }

                        if (email.getUnstableTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.UnstableTrigger' emailTrigger(email.getUnstableTriggerSubject())
                        }

                        if (email.getAbortedTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.AbortedTrigger' emailTrigger(email.getAbortedTriggerSubject())
                        }

                        if (email.getAlwaysTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.AlwaysTrigger' emailTrigger(email.getAlwaysTriggerSubject())
                        }
                        if (email.getStatusChangedTriggerSubject() != null) {
                            'hudson.plugins.emailext.plugins.trigger.StatusChangedTrigger' emailTrigger(email.getStatusChangedTriggerSubject())
                        }
                    }
                    contentType 'default'
                    defaultSubject email.getSubject()
                    defaultContent email.getContent()
                    'attachmentsPattern' { }
                    'presendScript' '$DEFAULT_PRESEND_SCRIPT'
                    'attachBuildLog' 'false'
                    'compressBuildLog' 'false'
                    'replyTo' '$DEFAULT_REPLYTO'
                    'saveOutput' 'false'
                    'disabled' 'false'
                }
            }
        }
    }

    protected Closure emailTrigger(String subjectValue) {
        return {
            email {
                recipientList ''
                subject subjectValue
                body '$PROJECT_DEFAULT_CONTENT'
                recipientProviders {
                    'hudson.plugins.emailext.plugins.recipients.ListRecipientProvider' { }
                    'hudson.plugins.emailext.plugins.recipients.RequesterRecipientProvider' { }
                }
                'attachmentsPattern' { }
                'attachBuildLog' 'false'
                'compressBuildLog' 'false'
                'replyTo' '$PROJECT_DEFAULT_REPLYTO'
                'contentType' 'project'
            }
        }
    }

    protected String defaultFallbackScript() {
        return 'return ["Error evaluating Groovy script."]'
    }

    protected void addVersionChoiceParam(String parameterName, String metadataPath, String desc = "",
                                         boolean addManualInput = false, boolean addLatestVersion = true) {
        String version_script = 'version_list = []\n' +
            'metadataPath = "' + metadataPath + '"\n' +
            '\n' +
            'try {\n' +
            "    files = metadataPath.tokenize(',')\n" +
            "    for (String file : files) {\n" +
            "        (path, fromversion) = file.tokenize(';')\n" +
            "        metadata = new XmlSlurper().parse(path + '/maven-metadata.xml')\n" +
            '        metadata.versioning.versions.version.each{\n' +
            '            if (!fromversion || includeVersion(fromversion, it.text())) {\n' +
            '                version_list.add(it.text())\n' +
            '            }\n' +
            '        }\n' +
            '    }\n' +
            '} catch (IOException e) {}\n' +
            '\n' +
            'version_list.sort{a, b-> a == b ? 0 : includeVersion(b, a) ? -1 : 1}\n'
        int index = 0
        if (addLatestVersion) {
            version_script += 'version_list.add(' + index + ', "LATEST:selected")\n'
            index += 1
        }
        if (addManualInput) {
            version_script += 'version_list.add(' + index + ', "MANUAL INPUT")\n'
        }
        version_script += '\n' +
            'return version_list\n' +
            '\n' +
            '/*\n' +
            ' * The sorting algorith will first run a 2 part tokenizer\n' +
            ' * splitting away anything after a "-" for a string compare\n' +
            ' * and every "." for an integral compare.\n' +
            ' * \n' +
            ' * Each version part (major, minor, micro) is compared in\n' +
            ' * order and returns an early result on missmatch.\n' +
            ' * If all version parts are equal we run the string compare\n' +
            ' * if available (both version strings contain a "-") and\n' +
            ' * return the result.\n' +
            ' *\n' +
            '*/\n' +
            'boolean includeVersion(String limitVer, String requestVer) {\n' +
            '    limitrcpart = null\n' +
            '    requestrcpart = null\n' +
            '    limitParts = ""\n' +
            '    requestParts = ""\n' +
            '\n' +
            '    if (limitVer.contains("-") && requestVer.contains("-")) {\n' +
            '        limitrcparts = limitVer.tokenize("-")\n' +
            '        requestrcparts = requestVer.tokenize("-")\n' +
            '        limitrcpart = limitrcparts[1]\n' +
            '        requestrcpart = requestrcparts[1]\n' +
            '        limitParts = limitrcparts[0].tokenize(".")\n' +
            '        requestParts = requestrcparts[0].tokenize(".")\n' +
            '    } else {\n' +
            '        limitParts = limitVer.tokenize(".")\n' +
            '        requestParts = requestVer.tokenize(".")\n' +
            '    }\n' +
            '\n' +
            '    for (int i = 0; i < 3; i++) {\n' +
            '        try {' +
            '            limitNum = limitParts[i].toInteger()\n' +
            '            requestNum = requestParts[i].toInteger()\n' +
            '\n' +
            '            if (requestNum < limitNum) {\n' +
            '                return false\n' +
            '            }\n' +
            '            else if (requestNum > limitNum) {\n' +
            '                return true\n' +
            '            }\n' +
            '        }\n' +
            '        catch (Exception e) {\n' +
            '            return false\n' +
            '        }\n' +
            '    }\n' +
            '    if (limitrcpart && requestrcpart) {\n' +
            '        return limitrcpart.compareTo(requestrcpart)\n' +
            '    }\n' +
            '    return true\n' +
            '}\n'

        job.with {
            parameters {
                activeChoiceParam(parameterName) {
                    description(desc)
                    choiceType('SINGLE_SELECT')
                    groovyScript {
                        script(version_script)
                        fallbackScript(defaultFallbackScript())
                    }
                }
            }
        }
    }

    protected void addStringParam(String parameterName, String defaultValue = null,
                                  String description = null) {
        job.with {
            parameters {
                stringParam(parameterName, defaultValue, description)
            }
        }
    }

    protected void addListChoiceParam(String parameterName, List choiceList, String desc = "") {
        job.with {
            parameters {
                choiceParam(parameterName, choiceList, desc)
            }
        }
    }

    protected void addActiveChoiceReactiveParam(String parameterName, String _choiceType, String _script, String _fallbackScript, List referenceParams,
                                                Boolean isFilterable, String desc = "") {
        job.with {
            parameters {
                activeChoiceReactiveParam(parameterName) {
                    description(desc)
                    filterable(isFilterable)
                    choiceType(_choiceType)
                    groovyScript {
                        script(_script)
                        fallbackScript(_fallbackScript)
                    }
                    for (String param: referenceParams) {
                        referencedParameter(param)
                    }
                }
            }
        }
    }

    /**
     * Allows to configure projects which can copy artifacts of this project.
     * @param allowedProjects Comma seperated list of projects that can copy artifacts of this project. Wild card character ('*') is available.
     */
    protected void addPermissionToCopyArtifact(String allowedProjects) {
        job.with {
            configure {
                it / 'properties' / 'hudson.plugins.copyartifact.CopyArtifactPermissionProperty' / 'projectNameList' { string(allowedProjects) }
            }
        }
    }

    /**
     * Allows to configure projects which can copy artifacts of this project.
     * @param allowedProjects List of projects that can copy artifacts of this project. Wild card character ('*') is available.
     */
    protected void addPermissionToCopyArtifact(List<String> allowedProjects) {
        addPermissionToCopyArtifact(allowedProjects.join(','))
    }

    protected void deleteWorkspaceBeforeBuildStarts() {
        job.with { wrappers { preBuildCleanup() } }
    }

    protected void deleteWorkspaceAfterBuild() {
        job.with { publishers { wsCleanup() } }
    }

    protected void setJenkinsUserBuildVariables() {
        job.with { wrappers { buildUserVars() } }
    }

    protected void setBuildDescription(String description) {
        job.with {
            publishers { buildDescription(description) }
        }
    }

    protected void setProjectDescription(String desc) {
        job.with { description(desc) }
    }

    protected void setJDK(String version = JDK_VERSION) {
        job.with { jdk(version) }
    }

    protected void buildPeriodically(String cronExpression) {
        job.with {
            triggers { cron(cronExpression) }
        }
    }

    protected void setPropertiesFile(String propFile) {
        job.with {
            steps {
                environmentVariables {
                    propertiesFile(propFile)
                }
            }
        }
    }

    protected String getJavaVersion() {
        return RepositoryJavaConfig.instance.getJavaVersion(gerritName)
    }

    protected String getMavenVersion(String branchName) {
        return RepositoryMavenConfig.instance.getMavenVersion(gerritName, branchName)
    }

    protected String getMavenHome(String branchName = 'master') {
        return "/opt/local/dev_tools/maven/apache-maven-" + getMavenVersion(branchName)
    }

    protected String getMavenInstallationName(String branchName = 'master') {
        return 'Maven ' + getMavenVersion(branchName)
    }

    protected void emailNotification(String recipients, Boolean dontNotifyEveryUnstableBuild, Boolean sendToIndividuals) {
        job.with {
            publishers {
                mailer(recipients, dontNotifyEveryUnstableBuild, sendToIndividuals)
            }
        }
    }

    protected void archiveArtifacts() {
        archiveCrashLog()
    }

    private void archiveCrashLog() {
        job.with{
            publishers {
                archiveArtifacts {
                    allowEmpty(true)
                    pattern('**/hs_err_pid*.log')
                }
            }
        }
    }

    protected void setConcurrentBuild(boolean allowConcurrentBuild = true) {
        job.with {
            concurrentBuild(allowConcurrentBuild)
        }
    }

    protected void setThrottleConcurrentConfig(int maxConcurrent) {
        job.with {
            concurrentBuild(true)
            throttleConcurrentBuilds {
                maxTotal(maxConcurrent)
            }
        }
    }

    protected void discardOldBuilds(Integer daysToKeepBuilds, Integer maxBuildsToKeep) {
        job.with { logRotator(daysToKeepBuilds, maxBuildsToKeep) }
    }

    /**
     * Block build if certain job is running.
     * @param projectName Name of the certain job. Regular expressions can be used for the project names, e.g. /.*-maintenance/ will match all maintenance jobs.
     * @param blockLevel Possible values are 'GLOBAL' and 'NODE' (default).
     * @param scanQueueFor Possible values are 'ALL', 'BUILDABLE' and 'DISABLED' (default).
     */
    protected void blockBuildIfJobsAreRunning(String projectName, String _blockLevel, String _scanQueueFor) {
        job.with {
            blockOn(projectName) {
                blockLevel(_blockLevel)
                scanQueueFor(_scanQueueFor)
            }
        }
    }

    /**
     * Runs a shell script.
     * @param shellScript Shell script to run
     */
    protected void runAShellScript(String shellScript) {
        job.with {
            steps { shell(shellScript) }
        }
    }

    /**
     * Adds a Git SCM source.
     * @param repoURL Repository URL
     * @param branchToBuild Specify the branches to examine for changes and to build.
     * @param cleanUpBeforeCheckout Clean up the workspace before every checkout by deleting all untracked files and directories, including those which are
     * specified in .gitignore. Defaults to false.
     */
    protected void addGitRepository(String repoURL, String branchToBuild, boolean cleanUpBeforeCheckout) {
        job.with {
            scm {
                git {
                    remote { url(repoURL) }
                    clean(cleanUpBeforeCheckout)
                    branch(branchToBuild)
                }
            }
        }
    }

    /**
     * Disables the job, so that no new builds will be executed until the project is re-enabled.
     */
    protected void disable() {
        out.println("Creating job as disabled")
        job.with { disabled() }
    }

    /**
     * Enables the job.
     * If the system environment variable "ALL_DSL_JOBS_DISABLED" is set to true, this function
     * will not enable the job. This is used for test purposes to not activate jobs that
     * start automatically the first time they are created.
     */
    protected void enable() {
        String forceDisableForAllDSLJobs = System.getenv('ALL_DSL_JOBS_DISABLED') ?: 'false'
        if ('true'.equalsIgnoreCase(forceDisableForAllDSLJobs)) {
            this.disable()
        } else if (disableJobsIfFileExists()) {
            this.disable()
        } else {
            job.with { disabled(false) }
        }
    }

    /**
     *
     * @return
     */
    private boolean disableJobsIfFileExists() {
        FilePath disableJobsFile = getDisableJobsFilePath()
        try {
            if (disableJobsFile == null) {
                // This is needed to make the unit tests to pass. And the current unit test does
                // not test to create jenkins jobs as disabled anyway.
                return false
            }
            return disableJobsFile.exists()
        } catch (IOException e) {
            out.println("Could not check if file exists, due to: " + e)
            throw e
        }
    }

    private FilePath getDisableJobsFilePath() {
        try {
            def build = Thread.currentThread().executable

            if (build.workspace.isRemote()) {
                def channel = build.workspace.channel
                return new FilePath(channel, build.workspace.toString() + '/disableJobs')
            } else {
                return new FilePath(new File(build.workspace.toString() + '/disableJobs'))
            }
        } catch (MissingPropertyException ignore) {
            // This catch is only to make the unit test to pass during eta_jenkins_dsl_gerrit_unit_test job.
            // Before this can be removed, the tests needs to be able to mock a real Jenkins, or have an instance
            // of Jenkins.
        }
    }

    /**
     * Allows to configure build steps. Order of the steps matters.
     * @return
     */
    protected BuildStepsDecorator configureBuildSteps() {
        return new BuildStepsDecorator(job)
    }

    /**
     * Allows to configure post build steps. Order of the steps matters.
     * @return
     */
    protected PostBuildStepsDecorator configurePostBuildSteps() {
        return new PostBuildStepsDecorator(job)
    }

    /**
     * Allows to configure build environment.
     * @return
     */
    protected BuildEnvironmentDecorator configureBuildEnvironment() {
        return new BuildEnvironmentDecorator(job)
    }

    /**
     * Allows to configure build triggers.
     * @return
     */
    protected BuildTriggersDecorator configureBuildTriggers() {
        return new BuildTriggersDecorator(job)
    }

    /**
     * Allows to configure SCM's
     * @return
     */
    protected SCMDecorator configureScm() {
        return new SCMDecorator(job)
    }

    /**
     * Allows to configure project basic configuration.
     * @return
     */
    protected ProjectDecorator configureProject() {
        return new ProjectDecorator(job)
    }
}
